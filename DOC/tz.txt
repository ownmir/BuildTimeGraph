Скрипт завжди приймає такі дані (post, json):
1.	Timestamp початку
2.	Чи час виконання в годинах, чи ні (inHours, boolean)
3.	Якщо inHours=false, то timestamp закінчення; якщо inHours=true , то timestamp закінчення = undefined 
(потрібно сформувати в output)
4.	Якщо inHours=false, то тривалість (duration) в секундах рахується після отримання даних input як різниця 
timestamp закінчення та timestamp початку; якщо inHours=true, то тривалість як трансформування годин в секунди. 
Скрипт може приймати такі дані:
1.	Один, або декілька неробочих періодів (downtimes)
2.	Timestamp паузи
3.	Timestamp відновлення (resume)
Неробочі періоди (downtimes) типи можуть бути такими *:
1.	Дата-час “з” - дата-час “до” (timestamps) Наприклад 1605431465 - 1605521367
2.	Час “з” - час “до” (година(24):хвилина) Наприклад 19:00 - 9:00
3.	День тижня (з 1 по 7)
4.	День місяця (з 1 по 31)
5.	Місяць (з 1 по 12)
6.	Рік Наприклад 2021
Робочі періоди (worktimes):

Типи і формати такі ж самі, як і “неробочі періоди”. 
Робочі періоди мають більший пріоритет над неробочими періодами, 
тобто якщо на один і той же проміжок часу припадає неробочий і робочий період, то рахується робочий період, 
а неробочій ігнорується. Робочі періоди створюються тоді, коли виконавець вирішує працювати в неробочий період 
(виконавець вмикає режим “working ignoring downtimes”)
Timestamp паузи
Якщо в input присутній timestamp відновлення разом із timestamp паузи ТА timestamp відновлення МЕНШИЙ 
ніж timestamp паузи, то створюється новий робочий період worktime.
Timestamp, коли була поставлена пауза виконання. 
Якщо пауза припадає на робочий період, то останній робочій період в кінцевому результаті (timegraph) 
має закінчуватися на цьому timestamp. 
Якщо пауза припадає на неробочий період, то останній робочій період в timegraph має бути той, 
який передував цьому неробочому періоду.
Присутність паузи та inHours=true означає, що дата-час закінчення 0 (нуль), тобто не визначена.
Після паузи закінчується розрахунок timegraph.
Timestamp  відновлення
Якщо в input присутній timestamp відновлення разом із timestamp паузи ТА timestamp відновлення БІЛЬШИЙ ніж timestamp паузи, то ці обидва timestamps створюють новий неробочій період downtime 1)
Навпаки, якщо в input відсутній timestamp відновлення, то від timestamp відновлення до часу закінчення створюється суцільний робочий період, в якому неробочі періоди (downtimes) ігноруються. В такому разі, якщо inHours=true, то рахується кількість годин, що припадають на вже пройдений робочий час, ця величина віднімається від duration та таким чином створюється час закінчення (якщо inHours=false, то час закінчення такий, який був на початку отриманий скриптом від input)
Output: timegraph (json)
{
	“start”: timestamp початку,
	“deadline”: timestamp закінчення,
	“pause”: [масив-list з переліком timestamp , коли поставлена пауза],
	“resume”: [масив-list з переліком timestamp , коли відновлення]
}
На основі переліків pause та resume вже на frontend створюються “робочі” та “неробочі” періоди.
* Неробочі періоди в input можуть бути декілька кожного типу

Зауваження
Неробочі періоди можуть пересікатися та поглинатися одне одним. Коли пересікаються, то створюється більший по часу неробочій період, ніж кожен по окремості, але менший ніж їх часова сума.
Якщо час початку припадає на неробочій період (це потрібно визначити), то час початку переноситься та момент закінчення цього неробочого періоду (інший варіант, коли час початку не переноситься і рахується з моменту, який знаходиться в неробочому періоді є не обов’язковим ускладненням, тому не потребує нагальної реалізації і можна поки проігнорувати)
Ця задача не є високої пріоритетності, тому при наявності інших задач, її можна відкласти.
Якщо потрібно, можу надати доступ до інтерфейсу, де використовується наявний скрипт з цією функціональністю, щоб подивитися, як встановлення різних варіантів input створює output.

